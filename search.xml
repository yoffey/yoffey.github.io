<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK8十大特性]]></title>
    <url>%2FJDK8%E5%8D%81%E5%A4%A7%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[前言 简单总结JDK8十大特性 JDK8十大特性1.Lambda表达式 2.Stream函数式操作流元素集合 3.接口新增：默认方法与静态方法 4.方法引用(双冒号运算),与Lambda表达式联合使用 5.引入重复注解 6.类型注解 7.最新的Date/Time API (JSR 310) 8.新增base64加解密API 9.数组并行（parallel）操作 10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/** * Description: JDK8的特性. * All Rights Reserved. * * @version 1.0 2018/12/20 */public class Jdk8Features &#123; public List&lt;Integer&gt; list = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10); /** * 1.Lambda表达式 */ @Test public void testLambda() &#123; System.out.println("方式一：双冒号"); list.forEach(System.out::println); // 双冒号的作用：就是把方法当做参数传到stream内部，使stream的每个元素都传入到该方法里面执行一下。 System.out.println("方式二：-&gt;方式"); list.forEach(x -&gt; System.out.println(x)); // 第二种遍历打印的方式 &#125; /** * 2.Stream函数式操作流元素集合 */ @Test public void testStream() &#123; List&lt;Integer&gt; nums = Lists.newArrayList(1, 1, null, 2, 3, 4, null, 5, 6, 7, 8, 9, 10); int total = nums.stream() .filter(v -&gt; v != null) // 过滤非空 .distinct() // 去重 .mapToInt(v -&gt; v*2) // map操作 .skip(2) // 跳过前两个元素 .limit(4) // 限制取前四个元素 .peek(System.out::println) // 流式处理对象函数 .sum(); // 求和 System.out.println("求和：" + total); &#125; /** * 3.接口新增功能：interface可以实现默认方法和静态方法 * default 接口默认实现方法是为了让集合类默认实现这些函数式处理，而不用修改现有代码 * List接口继承Iterable接口，Iterable接口实现了默认方法default void forEach() */ @Test public void testDefaultMethod() &#123; // 可以直接使用【接口名.静态方法】的方式来访问接口中的静态方法 Jdk8Interface1.staticMethod(); // 接口中的默认方法必须通过实现类调用 new Jdk8InterfaceImpl1().defaultMethod(); // 同时实现了多个接口的实现类，默认方法重名的时候必须重写 new Jdk8InterfaceImpl2().defaultMethod(); &#125; public class Jdk8InterfaceImpl1 implements Jdk8Interface1 &#123; // 实现接口后，因为默认方法不是抽象方法，所以可以不重写// @Override// public void defaultMethod() &#123;//// &#125; &#125; public class Jdk8InterfaceImpl2 implements Jdk8Interface1,Jdk8Interface2 &#123; // 因为接口1和2，默认方法名相同，所以必须重写默认方法 @Override public void defaultMethod() &#123; // 默认方法重名的时候，不能直接通过【super.默认方法】调用父类方法，需要用如下写法 Jdk8Interface1.super.defaultMethod(); Jdk8Interface2.super.defaultMethod(); System.out.println("实现类重写重名的默认方法"); &#125; &#125; /** * 4.方法引用（双冒号语法），与Lambda表达式联合使用 */ @Test public void testMethodReference() &#123; // 构造器引用。语法是【Class:new】，或者【Class&lt;T&gt;::new】，要求构造器方法是没有参数的 final Car car = Car.create(Car::new); final List&lt;Car&gt; cars = Arrays.asList(car); // 静态方法引用，语法是【Class类名::静态方法】，要求接受一个Class类型的参数 Consumer&lt;Car&gt; consumer = Car::collide; cars.forEach(consumer); // 任意对象的方法引用，语法是【类名：成员方法】，要求无参 cars.forEach(Car::repair); // 特定对象的方法引用，语法是【实例对象::成员方法】,要求有参数，在某个对象上调用方法，将列表中的元素作为参数传入 final Car police = Car.create(Car::new); cars.forEach(police::follow); &#125; public static class Car &#123; public static Car create(final Supplier&lt;Car&gt; supplier) &#123; return supplier.get(); &#125; public static void collide(final Car car) &#123; System.out.println("静态方法引用 " + car.toString()); &#125; public void repair() &#123; System.out.println("任意对象的方法引用 " + this.toString()); &#125; public void follow(final Car car) &#123; System.out.println("特定对象的方法引用 " + car.toString()); &#125; &#125; /** * 5.引入重复注解 * 1.@Repeatable * 2.可以不用jdk8以前的“注解容器”写法，直接写两次相同注解即可 * &lt;p&gt; * Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。 */ @Test public void RepeateAnnotation() &#123; RepeateAnnotation.main(null); &#125; /** * 6.新增类型注解 * 新增类型注解： ElementType.TYPE_PARAMETER 表示这个 Annotation 可以用在 Type 的声明式前， * ElementType.TYPE_USE 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等）。 */ @Test public void elementType() &#123; Annotations.main(null); &#125; /** * 7.最新的Date/Time API(JSR 310) */ @Test public void dateTime() &#123;// Arrays.asList(TimeZone.getAvailableIDs()).forEach(System.out::println); // 1.Clock final Clock clock = Clock.systemUTC(); System.out.println(clock.getZone()); System.out.println(clock.instant()); System.out.println(clock.millis()); // 2.ISO-8601格式且无时区信息的日期部分 final LocalDate date = LocalDate.now(); final LocalDate date1 = LocalDate.now(clock); System.out.println(date); System.out.println(date1); // 3.ISO-8601格式且无时区信息的时间部分 final LocalTime time = LocalTime.now(); final LocalTime time1 = LocalTime.now(clock); System.out.println(time); System.out.println(time1); // 4.特定时区的日期/时间 final ZonedDateTime zonedDateTime = ZonedDateTime.now(); final ZonedDateTime zonedDateTime1 = ZonedDateTime.now(clock); final ZonedDateTime zonedDateTime2 = ZonedDateTime.now(ZoneId.of("America/Los_Angeles")); System.out.println(zonedDateTime); System.out.println(zonedDateTime1); System.out.println(zonedDateTime2); // 5.在秒与纳秒级别上的一段时间 final LocalDateTime from = LocalDateTime.of(2014, Month.APRIL, 16, 0, 0, 0); final LocalDateTime to = LocalDateTime.of(2015, Month.APRIL, 16, 23, 59, 59); final Duration duration = Duration.between(from, to); System.out.println("Duration in days: " + duration.toDays()); System.out.println("Duration in hours: " + duration.toHours()); &#125; /** * 8.新增base64加解密API */ @Test public void testBase64() &#123; final String text = "附近可大幅拉打开了房间克拉克拉发咖啡的快乐"; String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println("加密后：" + encoded); final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println("解密后：" + decoded); &#125; /** * 9.数组并行(parallel)操作 */ @Test public void testParallel() &#123; long[] arry = new long[20000]; // 1.给数组随机赋值 Arrays.parallelSetAll(arry, index -&gt; ThreadLocalRandom.current().nextInt(1000000)); // 2.打印出前10个元素 Arrays.stream(arry).limit(10).forEach(v -&gt; System.out.print(v + " ")); System.out.println(); // 3.数组排序 Arrays.parallelSort(arry); // 4.打印排序后的前10个元素 Arrays.stream(arry).limit(10).forEach(value -&gt; System.out.print(value + " ")); System.out.println(); &#125; /** * 10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间 */ @Test public void testMetaspace()&#123; //-XX:MetaspaceSize初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整 //-XX:MaxMetaspaceSize最大空间，默认是没有限制 //-XX:MinMetaspaceFreeRatio在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 //-XX:MaxMetaspaceFreeRatio在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 &#125;&#125; 引用到的其他类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Description: jdk8中支持接口定义静态方法和默认方法. * All Rights Reserved. * * @version 1.0 2018/12/20 */public interface Jdk8Interface1 &#123; // 1.接口中支持定义静态方法 public static void staticMethod() &#123; System.out.println("接口中的静态方法"); &#125; // 2.使用default可以定义为普通方法 public default void defaultMethod() &#123; System.out.println("接口中的默认方法"); &#125;&#125;/** * Description: . * All Rights Reserved. * * @version 1.0 2018/12/20 */public interface Jdk8Interface2 &#123; // 1.接口中支持定义静态方法 public static void staticMethod() &#123; System.out.println("接口2中的静态方法"); &#125; // 2.使用default可以定义为普通方法 public default void defaultMethod() &#123; System.out.println("接口2中的默认方法"); &#125;&#125;/** * Description: 新增类型注解：ElementType.TYPE_USE, ElementType.TYPE_PARAMETER. * All Rights Reserved. * * @version 1.0 2018/12/21 */public class Annotations &#123; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE_USE, ElementType.TYPE_PARAMETER&#125;) public @interface NonEmpty &#123; &#125; public static class Holder&lt;@NonEmpty T&gt; extends @NonEmpty Object &#123; public void method() throws @NonEmpty Exception &#123; &#125; &#125; public static void main(String[] args) &#123; final Holder&lt;String&gt; holder = new @NonEmpty Holder&lt;String&gt;(); @NonEmpty Collection&lt;@NonEmpty String&gt; strings = new ArrayList&lt;&gt;(); &#125;&#125;/** * Description: 重复注解@Repeatable. * All Rights Reserved. * * @version 1.0 2018/12/20 */public class RepeateAnnotation &#123; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Filters &#123; Filter[] value(); &#125; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) public @interface Filter &#123; String value(); String value2(); &#125; @Filter(value = "filter1", value2 = "111") @Filter(value = "filter2", value2 = "222") // 注意：JDK8之前：1.没有@Repeatable2.采用本行“注解容器”写法// @Filters(&#123;@Filter( value="filter1",value2="111" ),@Filter( value="filter2", value2="222")&#125;) public interface Filterable &#123; &#125; public static void main(String[] args) &#123; // 获取注解后遍历打印 for (Filter filter : Filterable.class.getAnnotationsByType(Filter.class)) &#123; System.out.println(filter.value() + filter.value2()); &#125; &#125;&#125; 其他博客Java 8十个lambda表达式案例 Java 8 特性 – 终极手册]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[前言 Markdown基本语法总结 正文列表无序列表 语法 12- 我是无序列表1- 我是无序列表2 效果 我是无序列表1 我是无序列表2 有序列表 语法 121. 我是有序列表12. 我是有序列表2 效果 我是有序列表1 我是有序列表2 列表嵌套上一级和下一级之间敲三个空格即可 效果 一级列表 二级列表 引用 语法 123&gt; 我是引用&gt;&gt; &gt; 我是嵌套的引用 效果 我是引用 我是嵌套的引用 代码块 语法 单行代码：代码两边被`包裹起来 /usr/local/myBlog 代码块：代码首尾被```包裹起来，反引号最好单独一行 效果 12345public class Test &#123; public static void main(String[] args) &#123; System.out.println("我是打印信息"); &#125;&#125; 表格 语法 1234| 姓名 | 学号 | 年龄 | 性别 || :--- | ---- | ---- | ---- || 11 | 22 | 33 | 44 || aa | bb | cc | dd | 效果 姓名 学号 年龄 性别 11 22 33 44 aa bb cc dd 图床 语法 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 1![图片alt](图片地址 "图片title") 效果 PicGo 微博图床插件 字体 加粗 字体两边用**包裹起来 斜体 字体两边用*包裹起来 斜体加粗 字体两边用***包裹起来 删除线 字体两边用~~包裹起来 分割线 语法 三个或者三个以上的-或者*都可以，显示效果是一样的 12--- *** 效果 超链接 语法 12[超链接名](超链接地址 "超链接title")title可加可不加 效果 百度 流程图 不支持，也不推荐安装插件，不好用 推荐用visio]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博客啦~]]></title>
    <url>%2F%E5%BC%80%E5%8D%9A%E5%AE%A2%E5%95%A6.html</url>
    <content type="text"><![CDATA[前言 鉴于有道笔记越来越难用，以及自己需要养成做知识梳理总结的习惯，痛定思痛，决定搞个博客来记录… emmmm，加油加油！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
